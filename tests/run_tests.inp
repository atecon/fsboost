set verbose off
clear

set assert stop

include "./src/fsboost.inp" --force

include assertion.gfn
include ridge.gfn --force
include regls.gfn
include string_utils.gfn


function void test_default_fsreg_opts (void)
    print "Start testing default_fsreg_opts()"

    bundle B = default_fsreg_opts()
print B
    assert(B.verbose == 1)
    assert(B.learning_rate == 0.01)
    assert(B.max_num_iterations == 10000)
    assert(B.early_stopping_rounds == 50)
    assert(B.early_stopping_threshold == 0.035)
    assert(B.early_stopping_strategy == "inner_product_rel")
end function
test_default_fsreg_opts()


open denmark.gdt -q -p
list L = LRY IBO const
function void test_initialize (const series y, const list L)
    print "Start testing initialize()"

    bundle B = null
    strings B.Xnames = varnames(L)
    scalar B.max_num_iterations = 10000
    initialize(&B, y, L)

    assert(inbundle(B, "T") != FALSE)
    assert(inbundle(B, "y") != FALSE)
    assert(inbundle(B, "X_wo_constant") != FALSE)
    assert(inbundle(B, "with_constant") != FALSE)
    assert(inbundle(B, "Xnames_wo_constant") != FALSE)
    assert(inbundle(B, "resid_mean") != FALSE)
    assert(inbundle(B, "rho_values") != FALSE)
    assert(inbundle(B, "betas") != FALSE)
    assert(inbundle(B, "actual_num_iterations") != FALSE)

    assert(B.T == $nobs)
    assert(B.with_constant == TRUE)
    assert(nelem(B.X_wo_constant) == (nelem(L)-1))
    assert(B.resid_mean == 0)
    assert(ok(B.actual_num_iterations) == FALSE)
    assert(cols(B.rho_values) == 1)
    assert(rows(B.rho_values) == B.max_num_iterations)
    assert(rows(B.betas) == B.max_num_iterations)
    assert(cols(B.betas) == nelem(B.X_wo_constant))
end function
test_initialize(LRM, L)


open denmark.gdt -q -p
list L = LRY IBO const
function void test_stdize_y_and_x (const series y, const list L)
    print "Start testing stdize_y_and_x()"

    bundle B = null
    series B.y = y
    list B.X_wo_constant = L

    stdize_y_and_x(&B)

    assert(inbundle(B, "my") != FALSE)
    assert(inbundle(B, "mX") != FALSE)
    assert(inbundle(B, "y") != FALSE)
    assert(inbundle(B, "X_wo_constant") != FALSE)
    assert(inbundle(B, "ysd") != FALSE)
    assert(inbundle(B, "Xsd") != FALSE)

    assert_almost_equal_num(B.ysd, 0.150966)
end function
test_stdize_y_and_x(LRM, L)


function void test_get_max_correlation (void)
    print "Start testing get_max_correlation()"

    # 1st draw
    set seed 1234
    matrix y = mnormal(100, 1)
    matrix X = mnormal(100, 11)
    scalar pos = 0

    scalar rho = get_max_correlation(y, X, &pos)
    assert(pos == 2)
    assert_almost_equal_num(rho, 0.15986581)

    # 2nd draw
    set seed 4321
    matrix y = mnormal(100, 1)
    matrix X = mnormal(100, 11)
    scalar pos = 0

    scalar rho = get_max_correlation(y, X, &pos)
    assert(pos == 11)
    assert_almost_equal_num(rho, 0.17891685)
end function
test_get_max_correlation()


function void test_print_iteration_details (void)
    print "Start testing print_iteration_details()"

    bundle B = null
    B.verbose = 2
    B.max_num_iterations = 10

    print_iteration_details(B, 4, 0.11)
end function
test_print_iteration_details()


open denmark.gdt -q -p
function void test_add_sd_of_uhat (const series y)
    print "Start testing add_sd_of_uhat()"

    bundle B = defbundle("uhat", y)
    add_sd_of_uhat(&B)

    assert_almost_equal_num(B.uhat_variance, 0.152357, 1e-5)
end function
test_add_sd_of_uhat(LRM)


open denmark.gdt -q -p
function void test_add_first_order_residual (const series y)
    print "Start testing add_first_order_residual_corr()"

    bundle B = defbundle("uhat", y)
    add_first_order_residual_corr(&B)

    assert_almost_equal_num(B.uhat_first_order_corr, 0.199667, 1e-6)
end function
test_add_first_order_residual(LRM)


open denmark.gdt -q -p
list L = dataset
function void test_fsboost_predict (const list L)
    print "Start testing fsboost_predict()"

    # Without intercept, number of regressors correct
    bundle B = null
    scalar B.with_constant = FALSE
    matrix B.coeff = {1, 1, 0}
    smpl 1 5
    list X = IDE LRY IBO
    matrix pred = fsboost_predict(X, B)

    assert_almost_equal_num(pred[1], 5.9977, 1e-4)
    assert_almost_equal_num(pred[2], 5.9693, 1e-4)
    assert_almost_equal_num(pred[3], 5.9333, 1e-4)
    assert_almost_equal_num(pred[4], 5.9078, 1e-4)
    assert_almost_equal_num(pred[5], 5.8924, 1e-4)


    # Without intercept, number of regressors wrong
    bundle B = null
    scalar B.with_constant = FALSE
    matrix B.coeff = {1, 1, 0, 1}
    smpl 1 5
    list X = IDE LRY IBO
    matrix pred = fsboost_predict(X, B)

    assert(ok(pred)[1] == FALSE)

    # Without intercept, number of regressors correct but coefficient
    # vector to long
    bundle B = null
    scalar B.with_constant = FALSE
    matrix B.coeff = {1, 1, 0, 1}
    smpl 1 5
    list X = IDE LRY IBO
    matrix pred = fsboost_predict(X, B)

    assert(ok(pred)[1] == FALSE)


    # With intercept, number of regressors correct
    bundle B = null
    scalar B.with_constant = TRUE
    matrix B.coeff = {0.5, 1, 1, 0}
    smpl 1 5
    list X = IDE LRY IBO
    matrix pred = fsboost_predict(X, B)

    assert_almost_equal_num(pred[1], 6.4977, 1e-4)
    assert_almost_equal_num(pred[2], 6.4693, 1e-4)
    assert_almost_equal_num(pred[3], 6.4333, 1e-4)
    assert_almost_equal_num(pred[4], 6.4078, 1e-4)
    assert_almost_equal_num(pred[5], 6.3924, 1e-4)
end function
test_fsboost_predict(L)


open australia.gdt -q -p
function void test_fsreg (const list L)
    print "Start testing fsreg()"

    # Given
    series LHS = ldiff(L.PAU)
    series IUS = L.IUS
    series IAU = L.IAU
    list RHS = const LHS(-1 to -2) IUS(-1 to -2)  IAU(-1 to -2)
    bundle opts = defbundle("learning_rate", 0.025)
    matrix expected = {0.020856, 0.15520, 0.25516, 0.00078387,\
                      -0.00033219, 0.0018641, -0.0028965}'

    # When
    bundle B = fsreg(LHS, RHS, opts)
    actual = B.coeff

    # Then
    loop i=1..rows(actual)
        assert_almost_equal_num(actual[i] == expected[i], 10e-5)
    endloop
end function
test_fsreg(dataset)